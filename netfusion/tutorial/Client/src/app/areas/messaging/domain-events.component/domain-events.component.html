<nav-toolbar [isDisplayed]="true"></nav-toolbar>
<div class="area-content">
    <div class="plugin-summary">
        <h1 class="section-header">Plugin Summary</h1>
        <div class="portal-definition-list">
            <dl class="version-info">
                <dt>Nuget Package</dt><dd>{{nugetPackageName}}</dd>
                <dt>Documentation</dt><dd><a href="{{documentationUrl}}" target="_blank">View</a></dd>
            </dl>
        </div>
    </div>

    <div class="plugin-overview">
        <h1 class="section-header">Overview</h1>
        <ul>
            <li>Domain events represent an event that has taken place.</li>
            <li>Domain events are often published to notify other application components
                that a resource, managed by the application, has changed.
            </li>
            <li>Unlike commands, domain event do not have an associated result.</li>
            <li>
                Domain event handler methods can be synchronous or asynchronous based on the code it 
                needs to call.  However, from the perspective of the code publishing the domain event, 
                the call is always asynchronous.  This decouples the caller from the handlers and allows
                the handling code to change overtime without having to refactor any of the calling code.
                Since a domain-event can have multiple handlers, this also allows for a combination of
                synchronous and asynchronous handlers.   
            </li>
            <li>
                The base implementation invokes domain-event subscribers that are declared in-process to the
                code publishing the domain-event.  Other plugins, such as RabbitMQ and AMQP extend this base
                pipeline allowing domain-events to be published to topics and handled by out-of-process subscribers.
            </li>
            <li>A domain-event can have multiple one in-process subscribers.</li>
            <li>
                Since other plugins can extend the base messaging pipeline, publishing out-of-process 
                domain-vents are exactly the same as publishing in-process domain-events.  The code 
                publishing the domain-event is completely decoupled from how the domain-event is handled.
            </li>
            <li>
                Likewise, the subscribing to domain-events is almost identical regardless of being handled 
                in-process or out-of-process.  The only difference are attributes specified on handler 
                methods defined by the plug-ins extending the pipeline.  The attributes are used to specify, 
                for example, the topic to which the handler should be bound.  Also, the plug-ins extending 
                the base pipeline usually provide a way of mapping a given domain-event type to to an external 
                messaging concept, such as a topic, to which it is delivered when published. 
            </li>
        </ul>
    </div>

    <div class="plugin-usage">
        <h1 class="section-header">Usage Summary</h1>
        <ul>
            <li>Domain events are defined by implementing the IDomainEvent interface.  The base abstract 
                DomainEvent class provides a default implementation from which domain events can be derived.
            </li>
            <li>It is best for domain events to be simple POCOS that are immutable.</li>
            <li>Domain events are often created and published as a result of handling a command.</li>
            <li>Domain events are published by calling the Publish method on the IMessaging service contract.</li>
        </ul>
    </div>

    <div class="plugin-examples">
        <h1 class="section-header">Examples</h1>
        <p>
            
        </p>
        <div class="plugin-example">
            <h2 class="section-header">Sending Command</h2>
            <ul>
                <li>The NewAccountCreated class derives from the base DomainEvent class.</li>
                <li>The DomainEventController publish the domain event using the IMessagingService contract to multiple handlers.</li>
            </ul>
            <div class="inputs">
                    <div>
                        <textarea [(ngModel)]="newDomainEventBody"></textarea>
                    </div> 
                    <button type="submit" mat-raised-button (click)="onPublishDomainEvent()" color="primary">Send</button>
                </div>
                <div class="results">
                    <json-viewer [json]="newDomainEventResult" class="viewer"></json-viewer>
                </div>
        </div>
    </div>
</div>