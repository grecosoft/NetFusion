<nav-toolbar [isDisplayed]="true"></nav-toolbar>
<div class="area-content">
    <div class="plugin-summary">
        <h1 class="section-header">Plugin Summary</h1>
        <div class="portal-definition-list">
            <dl class="version-info">
                <dt>Nuget Package</dt><dd>{{nugetPackageName}}</dd>
                <dt>Documentation</dt><dd><a href="{{documentationUrl}}" target="_blank">View</a></dd>
                <dt>Exchange</dt><dd><a href="{{exchangeUrl}}" target="_blank">TemperatureReading</a></dd>
            </dl>
        </div>
    </div>

    <div class="plugin-overview">
        <h1 class="section-header">Overview</h1>
        <ul>
            <li>Unlike the direct an topic exchanges, a fan-out message exchange does not use the RouteKey to determine 
                which queues a message should be delivered.
            </li>
            <li>Subscribers are only notified of the domain-events when they are connected to the exchange and bound to a queue. </li>
            <li>Publisher defines the exchange.</li>
            <li>Publisher does not know all consumers of the exchange.</li>
            <li>Subscribers create queues on the exchange.</li>
            <li>A random GUID value is appended to the queue name specified by the subscriber.  This results in an uniquely
                named queue being created for each connected subscribing client.  If multiple, subscriber applications are 
                executing, domain-events will be delivered to all subscribers.
            </li>
            <li>When a subscribing client stops execution, all Fanout queues are automatically removed and recreated
                when the client is restarted.
            </li>
        </ul>
    </div>

    <div class="plugin-usage">
        <h1 class="section-header">Usage Summary</h1>
        <ul>
            <li>Domain events are simple POCO classes.</li>
            <li>Domain events derive from the common base <code-viewer type="net-fusion" name="Core/NetFusion.Messaging.Types/DomainEvent.cs">DomainEvent</code-viewer> class used by all NetFusion plugins and components.</li>
            <li>Publisher defines a derived <code-viewer type="net-fusion" name="Integration/NetFusion.RabbitMq/Publisher/ExchangeRegistryBase.cs">ExchangeRegistryBase</code-viewer> class used to specify to which exchange a domain event should be delivered when published.</li>
            <li>The common <code-viewer type="net-fusion" name="Core/NetFusion.Messaging/IMessagingService.cs">IMessagingService</code-viewer> implementation routes all domain events with a defined registry entry to RabbitMQ.</li>
            <li>As with in-process messaging, subscribers associate method handlers to be invoked when a domain event is received.</li>
            <li>The subscriber decorates a method with the <code-viewer type="net-fusion" name="Integration/NetFusion.RabbitMq/Subscriber/FanOutQueueAttribute.cs">FanOutQueueAttribute</code-viewer> specifying the route-key(s) for which messages,with a matching route-key value, should be delivered.</li>
            <li>The FanOutQueueAttribute will create a queue and bind it to the exchange using the specified route-key values.</li>
        </ul>
    </div>

    <div class="plugin-suggestions">
        <h1 class="section-header">Suggestions</h1>
        <ul>
            <li>Domain events represent something that has happened and to which other services are to be notified.</li>
            <li>Domain event should be immutable and defined withing a solution's domain project.</li>
            <li>Domain events published to fanout exchanges are often used for microservice notifications.</li>
            <li>It is best not to share types representing a domain event between solutions.</li>
        </ul>
    </div>
    <div class="plugin-examples">
        <h1 class="section-header">Examples</h1>
        <p>
            This example invokes a <code-viewer type="tutorial-webapi" name="Controllers/Integration/RabbitMqController.cs">WebApi controller</code-viewer> that 
            publishes a <code-viewer type="tutorial-components" name="Service.Domain/Events/TemperatureReading.cs">TemperatureReading</code-viewer> representing a temperature reading.  
            The subscribing console application defines a queue within the <code-viewer type="tutorial-client" name="Handlers/SampleFanoutHandler.cs">SampleFanoutHandler</code-viewer> handler.
        </p>
        <div class="plugin-example">
            <h2 class="section-header">Publishing Domain-Event</h2>
            <p>
                Enter the following temperature information and start multiple subscriber clients.  Each client
                will be notified when a domain-event is published.
            </p>
            <div class="inputs">
                <div>
                    <textarea [(ngModel)]="newDomainEventBody"></textarea>
                </div> 
                <button type="submit" mat-raised-button (click)="onPublishDomainEvent()" color="primary">Publish</button>
            </div>
            <div class="results">
                <json-viewer [json]="newDomainEventResult" class="viewer"></json-viewer>
            </div>
        </div>
    </div>
</div>