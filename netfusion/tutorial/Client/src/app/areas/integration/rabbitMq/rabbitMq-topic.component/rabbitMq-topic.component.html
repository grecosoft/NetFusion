<nav-toolbar [isDisplayed]="true"></nav-toolbar>
<div class="area-content">
    <div class="plugin-summary">
        <h1 class="section-header">Plugin Summary</h1>
        <div class="portal-definition-list">
            <dl class="version-info">
                <dt>Nuget Package</dt><dd>{{nugetPackageName}}</dd>
                <dt>Documentation</dt><dd><a href="{{documentationUrl}}" target="_blank">View</a></dd>
                <dt>Exchange</dt><dd><a href="{{exchangeUrl}}" target="_blank">RealEstate</a></dd>
                <dt>Queues</dt>
                <dd>
                    <div><a href="{{germanAutoSalesQueueUrl}}" target="_blank">GermanAutoSales</a></div>
                    <div><a href="{{americanAutoSalesQueueUrl}}" target="_blank">AmericanAutoSales</a></div>
                    <div><a href="{{sweetishAutoSalesUrl}}" target="_blank">SweetishAutoSales</a></div>
                </dd>
            </dl>
        </div>
    </div>

    <div class="plugin-overview">
        <h1 class="section-header">Overview</h1>
        <ul>
            <li>Domain-event delivered to queues bound with a route-key pattern matching the route-key value associated with the message.</li>
            <li>The values within the RouteKey are often based on property values of the associated domain-event.</li>
            <li>Publisher defines the exchange.</li>
            <li>Publisher does not know all consumers of the exchange.</li>
            <li>Subscribers create queues on the exchange.</li>
            <li>Each subscriber created queue is bound to the exchange by one or more route-key patterns.</li>
            <li>The route-key pattern specified by subscribers is a period delimited value such as VW.*.2017.</li>
            <li>The * value within the pattern is used to indicate all values.</li>
            <li>The plug-in ID of the host application is appended to the queue name specified by the subscriber.
                If multiple, subscriber applications are executing, domain-events will be delivered round-robin
                between the subscribers bound to the queue.
            </li>
        </ul>
    </div>

    <div class="plugin-usage">
        <h1 class="section-header">Usage Summary</h1>
        <ul>
            <li>Domain events are simple POCO classes.</li>
            <li>Domain events derive from the common base <code-viewer type="net-fusion" name="Core/NetFusion.Messaging.Types/DomainEvent.cs">DomainEvent</code-viewer> class used by all NetFusion plugins and components.</li>
            <li>Publisher defines a derived <code-viewer type="net-fusion" name="Integration/NetFusion.RabbitMq/Publisher/ExchangeRegistryBase.cs">ExchangeRegistryBase</code-viewer> class used to specify to which exchange a domain event should be delivered when published.</li>
            <li>The common <code-viewer type="net-fusion" name="Core/NetFusion.Messaging/IMessagingService.cs">IMessagingService</code-viewer> implementation routes all domain events with a defined registry entry to RabbitMQ.</li>
            <li>As with in-process messaging, subscribers associate method handlers to be invoked when a domain event is received.</li>
            <li>The subscriber decorates a method with the <code-viewer type="net-fusion" name="Integration/NetFusion.RabbitMq/Subscriber/TopicQueueAttribute.cs">TopicQueueAttribute</code-viewer> specifying the route-key(s) for which messages, with a matching route-key value, should be delivered.</li>
            <li>The TopicQueueAttribute will create a queue and bind it to the exchange using the specified route-key values.</li>
        </ul>
    </div>

    <div class="plugin-suggestions">
        <h1 class="section-header">Suggestions</h1>
        <ul>
            <li>Domain events represent something that has happened and to which other services are to be notified.</li>
            <li>Domain event should be immutable and defined withing a solution's domain project.</li>
            <li>Domain events published to topic exchanges are often used for microservice integrations.</li>
            <li>It is best not to share types representing a domain event between solutions.</li>
        </ul>
    </div>
    <div class="plugin-examples">
        <h1 class="section-header">Examples</h1>
        <p>
            This example invokes a <code-viewer type="tutorial-webapi" name="Controllers/Integration/RabbitMqController.cs">WebApi controller</code-viewer> that publishes the 
            <code-viewer type="tutorial-components" name="Service.Domain/Events/AutoSaleCompleted.cs">AutoSaleCompleted</code-viewer> domain-event where the Make, Model, and Year properties
            of the domain event are used as the route-key value.  The publisher defines a <code-viewer type="tutorial-components" name="Service.Infra/ExchangeRegistry.cs">Registry</code-viewer> used
            to specify the queue to which the domain-event is associated.  The subscribing console application, withing the <code-viewer type="tutorial-client" name="Handlers/SampleTopicHandler.cs">SampleTopicHandler</code-viewer> 
            handler defines two queues with the specified patterns:            
        </p>
        <dl>
            <dt>GermanAutoSales</dt><dd>VW.*.2017, Buick.*.2019</dd>
            <dt>AmericanAutosSales</dt><dd>Chevy.*.2017, Buick.*.2019</dd>
            <dt>SweetishAutoSales</dt><dd>SAAB.*.*, VOLVO.*.*, NEVS.*.2019</dd>
        </dl>
        <div class="plugin-example">
            <h2 class="section-header">Publishing Domain-Event</h2>
            <p>
                Publishes a domain event indicating that an automobile sale has been completed.  Publish various domain events
                with values matching and not matching the above patterns.  Only domain events with a route-key matching one of
                the above patterns will be delivered to the subscriber console application. 
            </p>
            <div class="inputs">
                <div>
                    <textarea [(ngModel)]="newDomainEventBody"></textarea>
                </div> 
                <button type="submit" mat-raised-button (click)="onPublishDomainEvent()" color="primary">Publish</button>
            </div>
            <div class="results">
                <json-viewer [json]="newDomainEventResult" class="viewer"></json-viewer>
            </div>
        </div>
    </div>
</div>